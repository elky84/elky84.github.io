---
layout: post
title: (서평) 핵심 C++ 표준 라이브러리 - 우리 C++이 달라졌어요!
date: 2017-07-12 00:00:00
categories: [서평, C++, C++11]
tags: [서평, C++, C++11]
comments: true
---
내가 처음 프로그래밍을 시작한 언어는 C언어였다.

아니 정확히는 난 시작부터 C++이었다.

즉, 

~~~ cpp
#include <stdio.h>
int main(int argc, char* argv[])
{
    printf("Hello, World!\n");
    return 0;
}
~~~

이 아닌

~~~ cpp
#include <iostream>
int main(int argc, char* argv[])
{
    std::cout << "Hello, World!" << std::endl;
    return 0;
}
~~~

이었음을 말하는데, 컴파일러 기준으로 C++이지 나는 꽤나 오랜 기간 C 스타일로 코딩해왔다.


게임 개발 쪽에서 꽤나 긴 시간 당연한 선택은 C++이었다.

그렇다 보니 너도 나도 C++의 높은 허들을 넘어야만 했고, 그걸 넘은 사람만이 프로가 될 수 있었다.

이제와 밝히자면, 내가 툴 작업으로 업계에 알바로 염탐(?)했던 2000년대 초 당시의 게임 개발자 분들중에서는, 나처럼 C스타일 코딩을 고수하신 분들이 꽤 많았다.

실제로 일을 시작한 2005년도...뭐 별반 다르지 않았다 랄까?

물론 나 역시 배움의 깊이가 부족 했음은 당연히 인정한다.

내가 boost를 처음 접하게 된 것은, 2008년 경, 당시 프로그래밍 이사님이 알려주신 boost bind, boost function이 시작이었다.

이후 필요한 기능을 한 두개 씩 찾아서 쓰다가, C++ tr1 (technical report 1) 이라는 게 있다는 것을 알게 됐고, 그 것들이 boost의 기능 일부를 포함했음도 알게 됐다.

C++ 0x라고 해서, 차세대 C++ 기능을 0x (2000~09년) 사이엔 정식 포함될 줄 알았던 계획에서, C++  11 (2011)로 늦춰지면서 기술 보고서의 부분적 이식이 이뤄졌던 것이다.

boost의 기능들이 순차적으로 표준화 되고 있고, 실질적으로 boost가 차기 C++ 표준의 후보자 였다는 것도 알게 됐다.

나는 꽤나 긴 시간인 7년정도는 C++ 위주로만 사용했는데, 그 과정에서 아쉬움은 포인터, 함수 포인터, 문자열이었다.

Boost는 수 많은 C++ 개발자 사이에서 논란이 되거나, 자주 필요로 하는, 또는 다른 언어가 가진 장점을 흡수하려 노력했다.

심지어 개중에는 타 언어에서는 대부분 구현되지 않은 훌륭한 녀석 (multi_index같은)도 존재한다.

사실 C++ 표준은 레거시를 *포함*할 뿐, 권장하지 않는다.

Smart pointer (shared_ptr, unique_ptr, weak_ptr)로써 소유권의 의미를 엄격하게 관리하길 바라며, 의도가 드러나는 코드를 원한다. 여러가지 이유로 raw ptr를 허용할 뿐이다.

또한 WIN32를 비롯한 POSIX 라이브러리를 직접 다루는 것이 그다지 직관적이지 않아 기능 하나를 구현할 때도, 수 많은 시행 착오를 겪어야 했던 지난날은 이제 안녕~

Chrono와 Time은 SYSTEM_TIME이나 time_t를 사용해야 했던 지난날의 아픔을 모두 잊어도 되게 해준다.

auto, r-value reference, enum class 등은 C++을 사용하며 아쉬웠던 틈을 빼곡히 채워준다.

멀티 리턴 값이 필요하다고? 그렇다면 tuple!

C++은 표준 라이브러리의 확장과 boost library의 발전으로 생산성과 속도, 표현력 등 많은 부분이 성장하고 있다.

물론 그럼에도 집중력과 노력을 기울여야만 그 장점을 이끌어 낼 수 있는 어려운 언어 임은 분명하다.

레거시를 포함하기에 실수의 여지를 포함하여 위 장점들을 다 놓칠 수 도 있다는 점도 인정한다.

하지만 그럼에도, 같은 포지션에서 경쟁력을 잃고 사라진 수많은 언어들과는 다르게 C++은 발전하고 있다. 

C++의 몇가지 단점들을 커버할 수만 있다면, 결국 C++의 수명은 예상보다 훨씬 더 길어 질 수 있지 않을까?
